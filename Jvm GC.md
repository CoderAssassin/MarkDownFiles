[TOC]
## 对象死亡回收
#### 对象死亡判断
* 引用计数法
给对象加上一个**引用计数器**，每当有一个地方引用它的时候，引用计数器的值就加1，引用失效的时候，减1。当引用计数器的值为0的时候，该对象可以回收。
缺陷：难以处理循环引用。
* 可达性分析法
以一系列**“GC Roots”**对象为起点，沿着这些节点往下搜索，搜索的路径为**"引用链"**，若一个对象没有到GC Roots的引用链，那么该对象就可以被回收。
> 可作为GC Roots的对象：
> * 虚拟机栈中引用的对象
> * 方法区静态属性引用的对象
> * 方法区常量引用的对象
> * 本地方法栈中JNI引用的对象

#### 可达性分析法中对象的死亡标记
可达性分析法中对象的死亡要经过两次标记。
* 第一次标记：标记对象是否是不可达的对象。
* 第二次标记：判断对象是否有finalize()方法，有的话将该对象加入F-Queue中，该方法只会被系统调用一次，进行一些最后的处理，可以再该方法中和引用链上的对象建立关联，这样的话该对象就会"复活"，不会被回收。

#### 引用分类
* 强引用
用new这种方法创建的对象。只要对象是被强引用，那么永远不会被垃圾收集器回收。
* 软引用
有用但是非必须的对象。在抛出内存溢出(OutOfMemory)异常之前(或者说内存不足的时候)会对软引用进行回收，在回收完软引用之后如果内存还不够，那么会抛出内存溢出异常。软引用也可以和一个引用队列联合使用，垃圾回收后会将对象的软引用放入引用队列中，可以通过判断引用队列是否有该对象的软引用来判断该对象是否被回收。
* 弱引用
描述非必须的对象，只能生存到下一次垃圾回收之前，在gc的时候只要弱引用的对象被扫描到就会被垃圾回收。弱引用也可以和一个引用队列一起使用，当对象被gc后，会将弱引用加入该队列中。
* 虚引用
虚引用不会对对象生存时间构成影响，也无法通过虚引用来取得一个对象实例。唯一作用是对象在垃圾回收之后会收到一条系统通知。虚引用必须和引用队列联合起来使用，当垃圾回收某个对象的时候，若该对象是虚引用的，那么会将该对象的虚引用加入到引用队列中，可以通过判断引用队列中是否有某个对象的虚引用来得知该对象是否将要被垃圾回收，从而在回收之前做一些事。

#### 对于方法区的回收
方法区被称为永久带，并不是不会回收，只是相比于堆来说，回收的效益很低。
主要回收内容：**废弃常量**和**无用的类**。
判断废弃常量是否可以回收：判断是否没有对象引用该常量。
判断无用的类是否可以回收：

* 该类的所有的实例已经回收
* 类的ClassLoader已经回收
* 类的Class对象没有被引用  

## 垃圾收集算法
#### 标记-清除
遍历一遍，标记所有要清楚的对象，然后再回收这些对象。
缺陷：

* 效率低
* 标记清除后产生大量的内存碎片

![标记-清除](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/flag-clean.png?raw=true)

#### 复制
将内存分成大小相同的两块，每次只使用其中的一块，当该块用完的时候，将有数据的一块中存活的对象复制到另一块那，然后清楚原先的那一块的数据。
缺陷：使用内存少了一半。
新生代广泛采用，但并不是按1:1分，而是将内存划分成一块较大的Eden和两块小的Survivor，每次使用Eden和一块Survivor。回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor上，然后清理掉原来的对象。HotSpot默认大小Eden:Survivor=8:1。
![复制](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/copy.png?raw=true)

#### 标记-整理
先对要回收的对象标记，然后将存活的对象都向一端移动，清理掉边界以外的对象。
![标记-整理](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/flag-push.png?raw=true)

#### 分代收集
根据对象的存活周期分为新生代和老年代，新生代一般用复制算法，老年代一般用标记-清除或标记-整理。

## HotSpot的实现
#### 枚举根节点
因为GC Roots根节点要不来自方法区，要不来自栈帧，若方法区很大，所以查找引用会很费时。而且，所有垃圾收集器GC都是要停顿(Stop-The-World)的，在进行可达性分析是在快照上进行。不可能停顿下来一个一个地找对象引用，虚拟机需要有办法直接知道哪些地方有对象引用。在HotSpot中，使用OopMap数据结构，在类加载完成后，把*什么偏移量上是什么类型的数据计算出来*。

#### 安全点
HotSpot只在特定的位置生成OopMap，这些位置为安全点。
标准：程序是否具有**让程序长时间执行**的特征，例如方法调用和循环跳转等指令会产生安全点。
如何让线程到最近的安全点停顿？
1.抢先式中断：GC发生时，先把所有线程中断，将不在安全点的线程恢复到安全点。
2.主动式中断：GC发生时不中断线程，设置标志，线程执行时在各个安全点轮询标志，中断标志位为真的时候中断。

#### 安全区域
若程序没有分配CPU时间，即Sleep状态或者Blocked状态，无法响应中断，不可能等线程拿到cpu，所以设置安全区域，即在一段代码片段中，引用关系不会发生变化，在该区域的任何地方GC都安全。

## 垃圾收集器
![Garbage Collector](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/GarbageCollector.png?raw=true)

#### Serial收集器
单线程，GC的时候要暂停所有工作线程。
![Serial](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/Serial.png?raw=true)

#### ParNew收集器
Serial的多线程版本。
![ParNew](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/ParNew.png?raw=true)

#### Parallel Scavenge
特点：关注吞吐量(吞吐量=运行用户代码的时间/(运行用户代码的时间+GC时间))。

#### Serial Old
Serial的老年代版本。

#### Parallel Old
Parallel Scavenge老年代版本。

#### CMS(Concurrent Mark Sweep)
特征：以获取最短回收停顿时间为目标。
![CMS](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/CMS.png?raw=true)
步骤：
* 初始标记
停顿，标记GC Roots直接关联的对象。
* 并发标记
GC Roots Tracing。
* 重新标记
修正在并发标记阶段因为用户线程运行导致标记变动的那一部分对象的标记记录，停顿比初始标记稍长。
* 并发清除

缺陷：
* 对CPU敏感，因为默认CMS启动(当前CPU数+3)/4个cpu来gc，当cpu个数大于4个的时候，吞吐量会比较低，CMS对用户程序的影响小。
* 无法处理浮动垃圾，浮动垃圾指并发清除阶段用户进程产生的垃圾，在当次GC无法清除，所以需要在老年代还有一部分空间的时候收集，1.6中，默认老年代空间利用达到92%的时候回收.
* 因为是标记-清除算法，所以收集结束有大量空间碎片产生，大的对象就无法存，因此设置在顶不住要Full GC的时候开启内存碎片整理。

#### G1(jdk 1.7加进来)
特点:
* 并行与并发
* 分代收集
* 空间整合：总体标记-整理，局部复制
* 可预测的停顿：跟踪每个region的垃圾堆积价值大小(回收所获得的空间大小和回收所需时间的经验值)，维护优先列表，优先回收价值最大的Region

使用时的堆内存布局：将堆划分为多个大小相等的独立区域。
**Remember Set**：区域之间有对象引用，每个区域配一个set，当对象被引用，会将引用信息记录到被引用对象所在的堆的set中。
步骤：
* 初始标记
* 并发标记
* 最终标记
修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，将对象变化记录在Remember Set Logs，再把Logs合并到Remember Set中
* 筛选回收
对Region的回收价值和成本排序，回收。
![G1](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/G1.png?raw=true)

## 内存分配与回收策略
#### 对象优先在Eden分配
当Eden区没有足够空间的时候，虚拟机发起Minor GC(在新生代的GC)。

#### 大对象直接进入老年代
大对象：需要大量连续内存空间的对象，比如长字符串和数组。

#### 长期存活的对象进入老年代
虚拟机给每个对象定义对象年龄计数器，每当Minor GC后对象存活进入Survivor，那么计数器加1，当年龄达到一定阈值，进入老年代。

#### 动态对象年龄判定
若Survivor中相同年龄对象大小综合大于Survivor空间一半，将年龄大于等于该年龄的对象放入老年代。

#### 空间分配担保
Minor GC前判断老年代最大连续可用空间是否大于新生代对象总空间，是则安全；不是则虚拟机判断是否允许担保失败，是则继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于那么执行Minor GC，否则执行Full GC。