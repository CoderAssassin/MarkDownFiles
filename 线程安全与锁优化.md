[TOC]
## 线程安全
**线程安全**:当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

#### Java语言中的线程安全
1. 不可变
* 不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。
* 若共享数据是一个基本数据类型，只要在定义时使用final关键字修饰就可以保证它是不可变的；如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，最简单是把对象中带有状态的变量都声明为final；除了以上两个还有枚举类型，java.lang.Number的部分子类，但Number子类的AtomicInteger和AtomicLong并非不可变。

2. 绝对线程安全
	* 不管运行时环境如何，调用者都不需要任何额外的同步措施。
	* 注意：但是有些Java 类标的API标的是线程安全的，大多数都不是绝对的线程安全的。

3. 相对线程安全
	* 就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性
	* 比如Vector，HashTable等。
4. 线程兼容
	* 指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。
5. 线程对立
	* 指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码
	* 如Thread类的suspend()和resume()方法

#### 线程安全的实现方法

1. 互斥同步
	* 同步：指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。
	* synchronized关键字：编译后分别形成monitorenter和monitorexit两个字节码指令，都需要一个reference指明要锁定和解锁的对象，如果synchronized指定了对象参数，那就是该reference；若没有，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。synchronized是Java语言中一个重量级操作。
	* ReentranceLock：比synchronized多了三项：
		* 等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
		* 可实现公平锁：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。Synchronized是非公平，ReentranceLock默认也是非公平。
		* 锁绑定：指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁。

2. 非阻塞同步
	* 非阻塞同步：先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，即基于冲突检测的并发策略。
	* 需要硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有:
		* 测试并设置（Test-and-Set）
		* 获取并增加（Fetch-and-Increment）
		* 交换（Swap）
		* 比较并交换（Compare-and-Swap，下文称CAS）：需要3个操作数：内存位置(V)，旧的预期值(A)，新值(B)。当且仅当V等于旧预期值A时，处理器用新值B更新V的值，否则若V和内存位置V的值不相等的时候，说明内存位置V处的值已经被别的线程改动过，它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值。会出现"ABA"问题，指的是有别的线程将当前值从A改成C又有线程将值改回A，这时候值没变，但是值的版本变了，解决方法是加版本。
		* 加载链接/条件存储（Load-Linked/Store-Conditional，下文称LL/SC）。

3. 无同步方案
	* 可重入代码：也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。
		* 判断：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。
	* 线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内。
		* 比如大部分应用使用的生产者-消费者模式；经典的有Web交互模型中的“一个请求对应一个服务器线程”。

#### 锁优化
1. 自旋锁与自适应自旋
	* 自旋锁：共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。
	* 自旋次数的默认值是**10**次。
	* 自适应的自旋锁：自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如对某个锁，自旋很少成功获得过，那么在以后要获取这个锁时将可能省略掉自旋过程。

2. 锁消除
	* 锁消除：指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。
	* 主要判定依据：据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。

3. 锁粗化
	* 如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

4. 轻量级锁
	* 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 
	* HotSpot虚拟机的对象头的第一部分(Mark Word)存储的自身的运行时数据，如GC分代年龄等。Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。
		* 在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32bit空间中的25bit用于存储对象哈希码（HashCode），4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下：![markword](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/MarkWord.png?raw=true)
		* 在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的MarkWord的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图：![轻量级锁](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/light_lock1.png?raw=true)
		* 然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后2bit）将转变为“00”，如图：![轻量级锁１](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/light_lock2.png?raw=true)
		* 如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。
		* 解锁过程：如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。

5. 偏向锁
	* 目的：消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。
	* 如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。
	* 锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。
	* 当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。
![偏向锁](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/pianxiangsuo.png?raw=true)