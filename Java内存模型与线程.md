[TOC]
## 内存模型
作用：屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。此前，主流的语言都是直接使用的物理硬件和操作系统的内存模型。
#### 主内存与工作内存
所有的变量都存储在主内存中;每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。
![内存模型](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/MemoryModel.png?raw=true)

#### 内存交互操作
1. ８种操作
	* lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
	* unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
	* read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
	* load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
	* use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
	* assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
	* store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
	* write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
2. 规则
	* read后load，store后write，不允许单独出现。
		* **问题探讨：read是将变量从主内存读取到线程的工作内存，load是将变量从工作内存读取到工作内存的变量副本中，那么问题来了，read和load两个动作之间，变量是存在哪里？**
			* 网上关于这个问题探讨不多，目前为止感觉有点道理的回答是：read是将变量从主内存读入CPU cache中，然后load是将变量从cache中读取到线程栈中。
	* 变量在工作内存中改变了之后必须把该变化同步回主内存。
	* 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
	* 对一个变量实施use、store操作之前，必须先执行过了assign和load操作。
	* 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
	* 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
	* 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。
	* 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。
3. 对于volatile型变量的特殊规则
	* volatile
		* 第一语义：可见性。当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。
		* 第二语义：有序性。禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。
```
public class Singleton {
    public volatile static Singleton instance;
    public static Singleton getInstance(){
        if(instance==null){
            synchronized(Singleton.class){
                if(instance==null){
                    instance=new Singleton();
                }
            }
        }
        return instance;
    }
    public static void main(String[]args){
        Singleton.getInstance();
    }
}
    编译后，对instance变量赋值过程如下：
0x01a3de0f：mov$0x3375cdb0，%esi；……beb0cd75 33 ；{oop（'Singleton'）}
0x01a3de14：mov%eax，0x150（%esi）；……89865001 0000
0x01a3de1a：shr$0x9，%esi；……c1ee09
0x01a3de1d：movb$0x0，0x1104800（%esi）；……c6860048 100100
0x01a3de24：lock addl$0x0，（%esp）；……f0830424 00 ；*putstatic instance ；-
Singleton：getInstance@24
```
lock一行操作相当于一个**内存屏障**，指重排序时不能把后边的指令重排序到内存屏障之前的位置。只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或多个CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性。关键是lock前缀，作用是使得本CPU的Cache写入了内存，该写入动作也会引起别的CPU或者别的内核无效化（Invalidate）其Cache，这种操作相当于对Cache中的变量做了一次前面介绍Java内存模式中所说的“store和write”操作。所以通过这样一个空操作，可让前面volatile变量的修改对其他CPU立即可见。

4. 对于long和double型变量的特殊规则
允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性，这点就是所谓的long和double的非原子性协定。

5. 原子性、可见性与有序性
	* 原子性
		* 原子性变量操作包括read、load、assign、use、store和write，大致可以认为基本数据类型的访问读写是具备原子性。
		* Java内存提供lock和unlock，不直接开放给用户使用，可以使用monitorenter和monitorexit两个字节码隐式使用这两个操作，这两个字节码就是Java代码中的synchronized的底层实现。
	* 可见性
		* 指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。
		* 除了volatile，还有**synchronized和final**可以实现可见性。synchronized是因为对一个变量执行unlock操作之前，必须先把此变量同步回主内存中；final是因为被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。
	* 有序性
		* 如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。

6. 先行发生关系原则
是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。

7. 先行发生关系
	* 程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。
	* 管理锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作，后面指时间。
	* volatile变量规则：对一个volatile变量的写操作先行发生于后面（时间上）对这个变量的读操作。
	* 线程启动规则：Thread对象的start（）方法先行发生于此线程的每一个动作。
	* 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()和Thread.isAlive()。
	* 线程中断规则：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生。
	* 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。
	* 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

## Java与线程
#### 线程的实现
1. 使用内核线程实现
	* 直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器。
	* 一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程，即线程，只有先支持内核线程，才能有轻量级进程，一对一的线程模型如下：
	* 缺陷：
		* 因为是基于内核线程实现，所以线程操作都需要系统调用，代价高。
		* 每个轻量级线程都需要一个内核线程的支持，一个系统支持轻量级进程的数量是有限的。
![LWP](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/LWP.png?raw=true)

2. 使用用户线程实现
	* 定义
		* 广义上，一个线程只要不是内核线程，就是用户线程。
		* 狭义上，用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。
	* 一对多线程模型：
![UserThread](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/userThread.png?raw=true)
	* 优势在于没有系统内核支援，劣势也在于没有系统内核支援。

3. 使用用户线程加轻量级进程混合实现
	* 用户线程还是完全建立在用户空间中，而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。
	* N：M线程模型实现：
![混合模型](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/hunheThread.png?raw=true)
4. Java线程的实现
	* 目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定Java线程需要使用哪种线程模型来实现。
	* 对于Sun JDK，Windows和Linux版都是一对一的线程模型，而在Solaris可以同时支持一对一，及多对多。

5. Java线程调度
指系统为线程分配处理器使用权的过程。
	* 协同式线程调度
		*  线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上.
		*  优点:实现简单、没有什么线程同步问题。
		*  缺点:线程执行时间不可控制。
	* 抢占式调度
		* 每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。
		* 好处：线程执行时间可控，不会出现阻塞问题。

6. 状态转换
在任意一个时间点，一个线程只能有且只有其中的一种状态。
	* 新建：创建后尚未启动的线程。
	* 运行：包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。
	* 无限期等待：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态：
		* 没有设置Timeout参数的Object.wait（）方法。
		* 没有设置Timeout参数的Thread.join（）方法(让主线程等待子线程结束之后才能继续运行)。
		* LockSupport.park（）方法（让线程等待"许可"，该"许可"不可叠加，是一次性的）。
	* 限期等待：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
		* Thread.sleep（）方法。
		* 设置了Timeout参数的Object.wait（）方法。
		* 设置了Timeout参数的Thread.join（）方法。
		* LockSupport.parkNanos（）方法。
		* LockSupport.parkUntil（）方法。
	* 阻塞：在程序等待进入同步区域的时候，线程将进入这种状态。
	* 结束：已终止线程的线程状态，线程已经结束执行。
![状态转换](https://github.com/CoderAssassin/markdownImg/blob/master/JavaVM/Thread_statues.png?raw=true)