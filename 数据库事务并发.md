[TOC]
## 数据库中的事务和并发问题

#### 并发问题
* 丢失更新
	* 第一类丢失更新：原因是事务回滚。事务A和事务B同时对某一数据进行操纵，事务A进行完数据更改，事务B发生异常，执行回滚，将事务B以及事务A对该数据的更新回滚，这样事务A的更新也丢失了。
	* 第二类丢失更新：原因是事务覆盖。事务A和事务B同时对某一数据进行操纵，事务A更新完数据后事务B又对该数据进行了更新，那么事务A对该数据的更新就被覆盖了。
* 脏读
原因是事务A可以读到事务B的未提交的数据。这样事务B在更改完数据后还没有将数据提交到数据库，事务A这时候读取事务B的未提交的数据，这个时候事务B发生异常进行回滚，那么事务A读到的数据并不是数据库真正的数据。
* 不可重复读
原因是事务A在两次读同一数据的时候发现数据的值不一样。事务A第一次和第二次读之间有事务B对同一数据进行了更新，那么第二次读的时候就会发现读到的数据和第一次不一样。
* 幻读
原因是事务A再两次读数据的时候发现数据的结构发生了变化，即发生数据多了或者少了。事务A第一次和第二次读之间有事务B添加或者删除等操作使得数据的数量发生了变化，那么事务A第二次读的时候读到的数据结构和第一次的不一样。

#### 事务的隔离级别
* 读未提交(Read Uncommitted)
A事务读的时候B事务可以读和写，A事务写的时候**B事务可以读但是不能写**。重点是A写的时候B不能写，所以同时只能有1个事务对数据写操作，因此不可能发生第一类丢失更新问题，因为第一类丢失更新需要有多个事务同时进行写。通过写操作加"持续-X锁"实现。
* 读已提交(Read Commit)
A事务读的时候B事务可以读和写，A事务写的时候**B事务不能读也不能写**。重点是B事务不能读也不能写，那么只能等写完才能读，所以读到的都是最新的数据，也就没有脏读。通过写操作加"持续X-锁"，读操作加"临时S-锁"实现。
* 可重复读(Repeatable Read)
A事务读的时候**B事务可以读但是不能写**，A事务写的时候B事务不能读也不能写。这样的话读就一直读，写就一直写，不会交叉，所以不会出现A事务在两次读之间有B事务对数据进行更改，也就不会出现不可重复读和第二类丢失更新。通过写操作加"持续-X锁"，读操作加"持续S-锁"实现。
* 串行化(Serializable)
只能一个事务一个事务地进行，不会出现任何问题。需要使用"表级锁"。

||第一类丢失更新|脏读|不可重复读|第二类丢失更新|幻读|
|:-|:-|:-|:-|:-|:-|
|读未提交|X|可能发生|可能发生|可能发生|可能发生|
|读已提交|X|X|可能发生|可能发生|可能发生|
|可重复读|X|X|X|X|可能发生|
|串行化|X|X|X|X|X|

#### 数据库中的锁
* 共享锁(S-锁)
多个事务可以同时加共享锁读取某一资源，只能读不能更新。Select默认带共享锁。
* 排它锁(X-锁)
一个事务对数据更新的时候加排它锁，这时候其他事务不能加共享锁和排它锁。Update，Delete和insert默认带排它锁。
* 更新锁(U-锁)
多事务加排它锁之前都要先加共享锁，这时候抢排它锁会造成死锁，因此只有一个线程可以拿到更新锁，表示有更新意向，然后再加排它锁。

#### 三级加锁协议
所有事务必须遵守的规则！
* 一级加锁协议：事务改数据前必须加X锁，事务结束才能释放；读数据不用加锁。
* 二级加锁协议：满足一级，但读数据前必须加S锁，读完释放S锁。
* 三级加锁协议：满足一级，但读数据前必须加S锁，事务结束释放S锁。

## Reference
* [https://www.jianshu.com/p/71a79d838443](https://www.jianshu.com/p/71a79d838443)